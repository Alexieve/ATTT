-- Lấy các tên các cột của bảng
CREATE OR REPLACE PROCEDURE USP_GET_COLUMN_NAME
(
    P_TABLE_NAME IN VARCHAR2, 
    P_COLUMN_NAMES OUT SYS_REFCURSOR
) 
AS
BEGIN
    OPEN P_COLUMN_NAMES FOR
        SELECT COLUMN_NAME
        FROM USER_TAB_COLUMNS
        WHERE TABLE_NAME = P_TABLE_NAME;
END;
/

-- Lấy quyền của user trên bảng
CREATE OR REPLACE PROCEDURE USP_GET_PRIV_COL
(
    P_ROLE_USER_NAME IN VARCHAR2, 
    P_TABLE_NAME IN VARCHAR2, 
    P_ROLE_USER_PRIV OUT SYS_REFCURSOR
) 
AS
    P_CHECK_SELECT INT := 0;
BEGIN
    SELECT COUNT(*) INTO P_CHECK_SELECT
    FROM DBA_TAB_PRIVS
    WHERE TABLE_NAME = UPPER(P_TABLE_NAME)
    AND GRANTEE = UPPER(P_ROLE_USER_NAME)
    AND PRIVILEGE = 'SELECT';
        
    IF P_CHECK_SELECT = 0 THEN
        OPEN P_ROLE_USER_PRIV FOR
            SELECT COLUMN_NAME, PRIVILEGE, GRANTABLE
            FROM USER_COL_PRIVS
            WHERE TABLE_NAME = P_TABLE_NAME
            AND GRANTEE = UPPER(P_ROLE_USER_NAME);
    ELSE
        OPEN P_ROLE_USER_PRIV FOR
            SELECT COLUMN_NAME, PRIVILEGE, GRANTABLE
            FROM USER_COL_PRIVS
            WHERE TABLE_NAME = P_TABLE_NAME
            AND GRANTEE = UPPER(P_ROLE_USER_NAME)
            UNION ALL(
                SELECT COLUMN_NAME, 'SELECT' AS PRIVILEGE, 'NO' AS GRANTABLE
                FROM USER_TAB_COLUMNS
                WHERE TABLE_NAME = P_TABLE_NAME
                EXCEPT
                SELECT COLUMN_NAME, 'SELECT' AS PRIVILEGE, 'NO' AS GRANTABLE
                FROM USER_ROLE_ACCESS_CONDITIONS
                WHERE USER_ROLE = UPPER(P_ROLE_USER_NAME) 
                AND TABLE_NAME = P_TABLE_NAME
            );
    END IF;      
END;
/


-- Thu hồi tất cả các quyền SELECT trên bảng
CREATE OR REPLACE PROCEDURE USP_REVOKE_SELECT_PRIV(
    P_ROLE_USER_NAME IN VARCHAR2,
    P_TABLE_NAME IN VARCHAR2
)
AS
BEGIN
    DELETE FROM USER_ROLE_ACCESS_CONDITIONS
    WHERE USER_ROLE = UPPER(P_ROLE_USER_NAME) AND TABLE_NAME = UPPER(P_TABLE_NAME);
END;
/



-- Thu hồi tất cả các quyền UPDATE trên bảng
CREATE OR REPLACE PROCEDURE USP_REVOKE_UPDATE_PRIV(
    P_ROLE_USER_NAME IN VARCHAR2,
    P_TABLE_NAME IN VARCHAR2
)
AS
BEGIN
    EXECUTE IMMEDIATE 'REVOKE UPDATE ON ' || UPPER(P_TABLE_NAME) || ' FROM ' || UPPER(P_ROLE_USER_NAME);
EXCEPTION
    WHEN OTHERS THEN
        NULL;
END;
/


-- Hàm Chính sách chung cho quyền Select của user/role
CREATE OR REPLACE FUNCTION POL_FUNC_USER_ROLE_ACCESS_CONDITIONS (
    P_SCHEMA_NAME VARCHAR2,
    P_TABLE_NAME VARCHAR2
) 
RETURN VARCHAR2 
AS
    V_CONDITION INT := 0;
BEGIN
    SELECT COUNT(*) INTO V_CONDITION
    FROM USER_ROLE_ACCESS_CONDITIONS
    WHERE (USER_ROLE = SYS_CONTEXT('USERENV', 'SESSION_USER')
        OR EXISTS
        (
            SELECT 1
            FROM DBA_ROLE_PRIVS
            WHERE SYS_CONTEXT('USERENV', 'SESSION_USER') != 'C##ADMIN'
            AND GRANTEE = SYS_CONTEXT('USERENV', 'SESSION_USER')
            AND GRANTED_ROLE = USER_ROLE
    ))
    AND TABLE_NAME = P_TABLE_NAME;
    IF V_CONDITION > 0 THEN
        RETURN '1 = 2';
    ELSE
        RETURN '1 = 1';
    END IF;
END;
/


-- Hàm lấy các cột mà user được xem
CREATE OR REPLACE FUNCTION USP_GET_COL_USER_ROLE_ACCESS_CONDITIONS(
    P_USER_ROLE IN VARCHAR2,
    P_TABLE_NAME IN VARCHAR2
)
RETURN VARCHAR2
IS
    V_COLUMN_NAMES VARCHAR2(4000);
BEGIN
    FOR REC IN (SELECT COLUMN_NAME
                FROM USER_ROLE_ACCESS_CONDITIONS
                WHERE USER_ROLE = UPPER(P_USER_ROLE) AND TABLE_NAME = P_TABLE_NAME)
    LOOP
        IF V_COLUMN_NAMES IS NULL THEN
            V_COLUMN_NAMES := REC.COLUMN_NAME;
        ELSE
            V_COLUMN_NAMES := V_COLUMN_NAMES || ', ' || REC.COLUMN_NAME;
        END IF;
    END LOOP;

    RETURN V_COLUMN_NAMES;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN NULL;
END;
/

-- Cấp quyền trên cột cho user
CREATE OR REPLACE PROCEDURE USP_GRANT_PRIV_COL
(
    P_ROLE_USER_NAME IN VARCHAR2, 
	P_TABLE_NAME IN VARCHAR2, 
	P_COLUMN_NAME IN VARCHAR2, 
	P_SELECT IN VARCHAR2,
    P_UPDATE IN VARCHAR2
)
AS

BEGIN
    BEGIN 
        IF P_SELECT = 'FALSE' THEN
            INSERT INTO USER_ROLE_ACCESS_CONDITIONS VALUES(UPPER(P_ROLE_USER_NAME), P_TABLE_NAME, P_COLUMN_NAME);
        ELSIF P_SELECT = 'TRUE' THEN
            EXECUTE IMMEDIATE 'GRANT SELECT ON ' || P_TABLE_NAME || ' TO ' || UPPER(P_ROLE_USER_NAME);
            DELETE FROM USER_ROLE_ACCESS_CONDITIONS
            WHERE USER_ROLE = UPPER(P_ROLE_USER_NAME) AND TABLE_NAME = P_TABLE_NAME AND COLUMN_NAME = P_COLUMN_NAME;
        END IF;
    EXCEPTION 
        WHEN OTHERS THEN
            NULL;
    END;
    
    

    IF P_UPDATE = 'CHECKED' THEN
        EXECUTE IMMEDIATE 'GRANT UPDATE (' || P_COLUMN_NAME ||  ') ON ' || P_TABLE_NAME || ' TO ' || UPPER(P_ROLE_USER_NAME);
    ELSIF P_UPDATE = 'INDETERMINATE' THEN
        EXECUTE IMMEDIATE 'GRANT UPDATE (' || P_COLUMN_NAME ||  ') ON ' || P_TABLE_NAME || ' TO ' || UPPER(P_ROLE_USER_NAME) || ' WITH GRANT OPTION';
    END IF;

END;
/


-- Áp dụng chính sách phân quyền trên cột
CREATE OR REPLACE PROCEDURE USP_APPLY_VPD_FOR_COL_PRIV(
    P_ROLE_USER_NAME IN VARCHAR2, 
	P_TABLE_NAME IN VARCHAR2
)
AS
    P_POLICY_NAME VARCHAR2(100) := '';
    P_CONDITION VARCHAR2(100) := '';
    P_COUNT_COL INT := 0;
BEGIN
    P_POLICY_NAME := 'POL_' || UPPER(P_ROLE_USER_NAME) || '_' || P_TABLE_NAME;
    BEGIN
        SELECT POLICY_NAME
        INTO P_CONDITION
        FROM DBA_POLICIES
        WHERE OBJECT_NAME = P_TABLE_NAME
        AND POLICY_NAME = P_POLICY_NAME;
        
        DBMS_RLS.DROP_POLICY(
            OBJECT_SCHEMA => 'C##ADMIN',
            OBJECT_NAME => P_TABLE_NAME,
            POLICY_NAME => P_POLICY_NAME
        ); 
        
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            NULL;
    END;
    
    SELECT COUNT(*)
    INTO P_COUNT_COL
    FROM USER_ROLE_ACCESS_CONDITIONS
    WHERE USER_ROLE = UPPER(P_ROLE_USER_NAME) AND TABLE_NAME = P_TABLE_NAME;
    
    P_CONDITION := USP_GET_COL_USER_ROLE_ACCESS_CONDITIONS(P_ROLE_USER_NAME, P_TABLE_NAME);
    
    IF P_COUNT_COL > 0 THEN
        DBMS_RLS.ADD_POLICY(
            OBJECT_SCHEMA => 'C##ADMIN',
            OBJECT_NAME => P_TABLE_NAME,
            POLICY_NAME => P_POLICY_NAME,
            POLICY_FUNCTION => 'POL_FUNC_USER_ROLE_ACCESS_CONDITIONS',
            sec_relevant_cols=> P_CONDITION,
            sec_relevant_cols_opt=> DBMS_RLS.ALL_ROWS,
            STATEMENT_TYPES => 'SELECT'
        );
    END IF;
    
END;
/